"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/mainScreen/chatbox/page",{

/***/ "(app-pages-browser)/./app/pinecone_operations/pinecone_retrieve.js":
/*!******************************************************!*\
  !*** ./app/pinecone_operations/pinecone_retrieve.js ***!
  \******************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryPinecone: function() { return /* binding */ queryPinecone; }\n/* harmony export */ });\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dotenv */ \"(app-pages-browser)/./node_modules/dotenv/lib/main.js\");\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! openai */ \"(app-pages-browser)/./node_modules/openai/index.mjs\");\n/* harmony import */ var _pinecone_database_pinecone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pinecone-database/pinecone */ \"(app-pages-browser)/./node_modules/@pinecone-database/pinecone/dist/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/*\n  Name: pinecone_retrieve.js\n  Modules: queryPinecone \n  Description: Program accepts a query (list of strings) from caller program.\n  Searches pinecone database for most similar vectors and returns result as array of objects.\n*/ // Required modules\n\n\n\ndotenv__WEBPACK_IMPORTED_MODULE_0__.config();\n// Initialize OpenAI configuration\nconst openaiClient = new openai__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n    // For now put in apikey directly.\n    //apiKey: process.env.OPENAI_API_KEY\n    apiKey: \"\"\n});\n// Initialize Pinecone\nconst pinecone = new _pinecone_database_pinecone__WEBPACK_IMPORTED_MODULE_1__.Pinecone({\n    // For now hardcode apiKey.\n    apiKey: process.env.PINECONE_API_KEY\n});\n// Set index name for pinecone.\nconst indexName = \"ai-tutor-index\";\n/**\n * @param {string} query - The search query string.\n * @returns {Array<number>} - An array of numbers representing the embedding vector. \n *  query can be list of strings or just string.\n * Passes query to ada to generate embedding for use in queryPinecone.\n * Structure is typical along with some error handling.\n*/ // I write this same function but in python in upload program. Maybe we should implement as seperate program.\nasync function generateEmbedding(query) {\n    try {\n        const response = await openaiClient.embeddings.create({\n            model: \"text-embedding-ada-002\",\n            input: [\n                query\n            ]\n        });\n        return response.data[0].embedding;\n    // Should implement better error handling and logging here.\n    } catch (error) {\n        console.error(\"Error generating embedding:\", error);\n        return null;\n    }\n}\n/** \n * Queries Pinecone for vectors matching the given query embedding.\n * @param {string} query - The search query string.\n * @param {string} userId - The user ID for filtering results.\n * @param {string} workspaceId - The workspace ID for filtering results.\n * @param {number} topK - Number of top results to return (default is 10).\n * @returns {response.matches} - An array of matching vectors from Pinecone.\n */ // I may want to implement an optional sourceId in the future.\nasync function queryPinecone(query, userId, workspaceId) {\n    let topK = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;\n    // Generate query embedding\n    const queryEmbedding = await generateEmbedding(query);\n    // Should implement better error handling and logging here.\n    if (!queryEmbedding) {\n        console.error(\"Embedding generation failed.\");\n        return \" \";\n    }\n    // Query Pinecone index with filters. Requests metadata.\n    try {\n        const index = pinecone.Index(indexName);\n        const response = await index.query({\n            vector: queryEmbedding,\n            topK: topK,\n            includeMetadata: true,\n            filter: {\n                user_id: userId,\n                workspace_id: workspaceId\n            }\n        });\n        // Return results in string format.\n        const formattedResults = response.matches.map((entry)=>\"Text: \".concat(entry.metadata.text, \"\\nSource Info: \").concat(entry.metadata.source_info, \"\\nAnnotations: \").concat(entry.metadata.annotations, \"\\nTags: \").concat(entry.metadata.tags)).join(\"\\n\\n\");\n        return formattedResults;\n    } catch (error) {\n        console.error(\"Error querying Pinecone:\", error);\n        return \" \";\n    }\n}\n// Export the function for external usage.\n // Test function to verify Pinecone query functionality\n // DELETE LATER.\n /*async function testPineconeRetrieve() {\n  const user_id = 'test_user';\n  const workspace_id = 'test_workspace';\n  const query = 'Julius Cesear';\n\n  try {\n    const pineconeResponse = await queryPinecone(query, user_id, workspace_id);\n    console.log('Raw Pinecone Response:', pineconeResponse);\n\n    pineconeResponse.forEach((entry, index) => {\n      console.log(`Result ${index + 1}:`);\n      console.log('Text:', entry.metadata.text);\n      console.log('Source Info:', entry.metadata.source_info);\n      console.log('Annotations:', entry.metadata.annotations);\n      console.log('Tags:', entry.metadata.tags);\n    });\n\n    const combinedString = pineconeResponse.map(entry =>\n      `${entry.metadata.text}\\nSource Info: ${entry.metadata.source_info}\\nAnnotations: ${entry.metadata.annotations}\\nTags: ${entry.metadata.tags}`\n    ).join('\\n\\n');\n\n    console.log('Combined String:', combinedString);\n  } catch (error) {\n    console.error('An error occurred while retrieving data from Pinecone:', error);\n  }\n}\n\n// Run the test\ntestPineconeRetrieve();\n*/  /*\n  Code works\n  Future plans:\n  Better error handling and logging.\n  Let users use their own keys.\n  Refractor code for modality. \n    Embedding should be done in seprate program and shared with upload.\n    Pinecone initilization should be done in seperate program and shared with upload.\n    Initilize pinecone once at start of app and reuse same connection to improve performance.\n  Keep a cache of embeddings in memory for similar queries -> \n    can match query string in memory to forgo embedding and query\n    can match embeddings in memory to forgo pinecone query\n  Handle queries in batches for when multiple users are using same pinecone connection.\n  Handle cases when pinecone returns no result or results that are too different from query.\n*/ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9waW5lY29uZV9vcGVyYXRpb25zL3BpbmVjb25lX3JldHJpZXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7O0FBS0EsR0FDQSxtQkFBbUI7QUFDUztBQUNBO0FBQzJCO0FBRXZEQSwwQ0FBYTtBQUdiLGtDQUFrQztBQUNsQyxNQUFNSSxlQUFlLElBQUlILDhDQUFNQSxDQUFDO0lBQzlCLGtDQUFrQztJQUNsQyxvQ0FBb0M7SUFDcENJLFFBQVE7QUFDVjtBQUVBLHNCQUFzQjtBQUN0QixNQUFNQyxXQUFXLElBQUlKLGlFQUFRQSxDQUFDO0lBQzVCLDJCQUEyQjtJQUMzQkcsUUFBUUUsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxnQkFBZ0I7QUFFdEM7QUFFQSwrQkFBK0I7QUFDL0IsTUFBTUMsWUFBWTtBQUVsQjs7Ozs7O0FBTUEsR0FDQSw2R0FBNkc7QUFDN0csZUFBZUMsa0JBQWtCQyxLQUFLO0lBQ3BDLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1ULGFBQWFVLFVBQVUsQ0FBQ0MsTUFBTSxDQUFDO1lBQ3BEQyxPQUFPO1lBQ1BDLE9BQU87Z0JBQUNMO2FBQU07UUFDaEI7UUFDQSxPQUFPQyxTQUFTSyxJQUFJLENBQUMsRUFBRSxDQUFDQyxTQUFTO0lBRWpDLDJEQUEyRDtJQUM3RCxFQUFFLE9BQU9DLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsT0FBTztJQUNUO0FBQ0Y7QUFHQTs7Ozs7OztDQU9DLEdBQ0QsOERBQThEO0FBQzlELGVBQWVFLGNBQWNWLEtBQUssRUFBRVcsTUFBTSxFQUFFQyxXQUFXO1FBQUVDLE9BQUFBLGlFQUFPO0lBQzlELDJCQUEyQjtJQUMzQixNQUFNQyxpQkFBaUIsTUFBTWYsa0JBQWtCQztJQUUvQywyREFBMkQ7SUFDM0QsSUFBSSxDQUFDYyxnQkFBZ0I7UUFDbkJMLFFBQVFELEtBQUssQ0FBQztRQUNkLE9BQU87SUFDVDtJQUVBLHdEQUF3RDtJQUN4RCxJQUFJO1FBQ0YsTUFBTU8sUUFBUXJCLFNBQVNzQixLQUFLLENBQUNsQjtRQUM3QixNQUFNRyxXQUFXLE1BQU1jLE1BQU1mLEtBQUssQ0FBQztZQUNqQ2lCLFFBQVFIO1lBQ1JELE1BQU1BO1lBQ05LLGlCQUFpQjtZQUNqQkMsUUFBUTtnQkFDTkMsU0FBU1Q7Z0JBQ1RVLGNBQWNUO1lBQ2hCO1FBQ0Y7UUFFQSxtQ0FBbUM7UUFDbkMsTUFBTVUsbUJBQW1CckIsU0FBU3NCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDQyxDQUFBQSxRQUM1QyxTQUE4Q0EsT0FBckNBLE1BQU1DLFFBQVEsQ0FBQ0MsSUFBSSxFQUFDLG1CQUE2REYsT0FBNUNBLE1BQU1DLFFBQVEsQ0FBQ0UsV0FBVyxFQUFDLG1CQUFzREgsT0FBckNBLE1BQU1DLFFBQVEsQ0FBQ0csV0FBVyxFQUFDLFlBQThCLE9BQXBCSixNQUFNQyxRQUFRLENBQUNJLElBQUksR0FDbEpDLElBQUksQ0FBQztRQUNQLE9BQU9UO0lBRVQsRUFBRSxPQUFPZCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE9BQU87SUFDVDtBQUNGO0FBRUEsMENBQTBDO0FBQ2pCLENBRXpCLHVEQUF1RDtDQUN2RCxnQkFBZ0I7Q0FDaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBLElBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3BpbmVjb25lX29wZXJhdGlvbnMvcGluZWNvbmVfcmV0cmlldmUuanM/ZDY1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBOYW1lOiBwaW5lY29uZV9yZXRyaWV2ZS5qc1xuICBNb2R1bGVzOiBxdWVyeVBpbmVjb25lIFxuICBEZXNjcmlwdGlvbjogUHJvZ3JhbSBhY2NlcHRzIGEgcXVlcnkgKGxpc3Qgb2Ygc3RyaW5ncykgZnJvbSBjYWxsZXIgcHJvZ3JhbS5cbiAgU2VhcmNoZXMgcGluZWNvbmUgZGF0YWJhc2UgZm9yIG1vc3Qgc2ltaWxhciB2ZWN0b3JzIGFuZCByZXR1cm5zIHJlc3VsdCBhcyBhcnJheSBvZiBvYmplY3RzLlxuKi8gXG4vLyBSZXF1aXJlZCBtb2R1bGVzXG5pbXBvcnQgZG90ZW52IGZyb20gJ2RvdGVudic7XG5pbXBvcnQgT3BlbkFJIGZyb20gJ29wZW5haSc7XG5pbXBvcnQgeyBQaW5lY29uZSB9IGZyb20gJ0BwaW5lY29uZS1kYXRhYmFzZS9waW5lY29uZSc7XG5cbmRvdGVudi5jb25maWcoKTtcblxuXG4vLyBJbml0aWFsaXplIE9wZW5BSSBjb25maWd1cmF0aW9uXG5jb25zdCBvcGVuYWlDbGllbnQgPSBuZXcgT3BlbkFJKHtcbiAgLy8gRm9yIG5vdyBwdXQgaW4gYXBpa2V5IGRpcmVjdGx5LlxuICAvL2FwaUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVlcbiAgYXBpS2V5OiBcIlwiXG59KTtcblxuLy8gSW5pdGlhbGl6ZSBQaW5lY29uZVxuY29uc3QgcGluZWNvbmUgPSBuZXcgUGluZWNvbmUoe1xuICAvLyBGb3Igbm93IGhhcmRjb2RlIGFwaUtleS5cbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5QSU5FQ09ORV9BUElfS0VZXG4gIC8vIGFwaUtleTogXCJcIlxufSk7XG5cbi8vIFNldCBpbmRleCBuYW1lIGZvciBwaW5lY29uZS5cbmNvbnN0IGluZGV4TmFtZSA9IFwiYWktdHV0b3ItaW5kZXhcIjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnkgLSBUaGUgc2VhcmNoIHF1ZXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBlbWJlZGRpbmcgdmVjdG9yLiBcbiAqICBxdWVyeSBjYW4gYmUgbGlzdCBvZiBzdHJpbmdzIG9yIGp1c3Qgc3RyaW5nLlxuICogUGFzc2VzIHF1ZXJ5IHRvIGFkYSB0byBnZW5lcmF0ZSBlbWJlZGRpbmcgZm9yIHVzZSBpbiBxdWVyeVBpbmVjb25lLlxuICogU3RydWN0dXJlIGlzIHR5cGljYWwgYWxvbmcgd2l0aCBzb21lIGVycm9yIGhhbmRsaW5nLlxuKi9cbi8vIEkgd3JpdGUgdGhpcyBzYW1lIGZ1bmN0aW9uIGJ1dCBpbiBweXRob24gaW4gdXBsb2FkIHByb2dyYW0uIE1heWJlIHdlIHNob3VsZCBpbXBsZW1lbnQgYXMgc2VwZXJhdGUgcHJvZ3JhbS5cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlRW1iZWRkaW5nKHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWlDbGllbnQuZW1iZWRkaW5ncy5jcmVhdGUoe1xuICAgICAgbW9kZWw6IFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiLFxuICAgICAgaW5wdXQ6IFtxdWVyeV1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVswXS5lbWJlZGRpbmc7XG5cbiAgICAvLyBTaG91bGQgaW1wbGVtZW50IGJldHRlciBlcnJvciBoYW5kbGluZyBhbmQgbG9nZ2luZyBoZXJlLlxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZW5lcmF0aW5nIGVtYmVkZGluZzpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cblxuLyoqIFxuICogUXVlcmllcyBQaW5lY29uZSBmb3IgdmVjdG9ycyBtYXRjaGluZyB0aGUgZ2l2ZW4gcXVlcnkgZW1iZWRkaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIHNlYXJjaCBxdWVyeSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVGhlIHVzZXIgSUQgZm9yIGZpbHRlcmluZyByZXN1bHRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmtzcGFjZUlkIC0gVGhlIHdvcmtzcGFjZSBJRCBmb3IgZmlsdGVyaW5nIHJlc3VsdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wSyAtIE51bWJlciBvZiB0b3AgcmVzdWx0cyB0byByZXR1cm4gKGRlZmF1bHQgaXMgMTApLlxuICogQHJldHVybnMge3Jlc3BvbnNlLm1hdGNoZXN9IC0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgdmVjdG9ycyBmcm9tIFBpbmVjb25lLlxuICovXG4vLyBJIG1heSB3YW50IHRvIGltcGxlbWVudCBhbiBvcHRpb25hbCBzb3VyY2VJZCBpbiB0aGUgZnV0dXJlLlxuYXN5bmMgZnVuY3Rpb24gcXVlcnlQaW5lY29uZShxdWVyeSwgdXNlcklkLCB3b3Jrc3BhY2VJZCwgdG9wSyA9IDEwKSB7XG4gIC8vIEdlbmVyYXRlIHF1ZXJ5IGVtYmVkZGluZ1xuICBjb25zdCBxdWVyeUVtYmVkZGluZyA9IGF3YWl0IGdlbmVyYXRlRW1iZWRkaW5nKHF1ZXJ5KTtcblxuICAvLyBTaG91bGQgaW1wbGVtZW50IGJldHRlciBlcnJvciBoYW5kbGluZyBhbmQgbG9nZ2luZyBoZXJlLlxuICBpZiAoIXF1ZXJ5RW1iZWRkaW5nKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVtYmVkZGluZyBnZW5lcmF0aW9uIGZhaWxlZC5cIik7XG4gICAgcmV0dXJuICcgJztcbiAgfVxuXG4gIC8vIFF1ZXJ5IFBpbmVjb25lIGluZGV4IHdpdGggZmlsdGVycy4gUmVxdWVzdHMgbWV0YWRhdGEuXG4gIHRyeSB7XG4gICAgY29uc3QgaW5kZXggPSBwaW5lY29uZS5JbmRleChpbmRleE5hbWUpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW5kZXgucXVlcnkoe1xuICAgICAgdmVjdG9yOiBxdWVyeUVtYmVkZGluZyxcbiAgICAgIHRvcEs6IHRvcEssXG4gICAgICBpbmNsdWRlTWV0YWRhdGE6IHRydWUsXG4gICAgICBmaWx0ZXI6IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICB3b3Jrc3BhY2VfaWQ6IHdvcmtzcGFjZUlkXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZXR1cm4gcmVzdWx0cyBpbiBzdHJpbmcgZm9ybWF0LlxuICAgIGNvbnN0IGZvcm1hdHRlZFJlc3VsdHMgPSByZXNwb25zZS5tYXRjaGVzLm1hcChlbnRyeSA9PiBcbiAgICAgIGBUZXh0OiAke2VudHJ5Lm1ldGFkYXRhLnRleHR9XFxuU291cmNlIEluZm86ICR7ZW50cnkubWV0YWRhdGEuc291cmNlX2luZm99XFxuQW5ub3RhdGlvbnM6ICR7ZW50cnkubWV0YWRhdGEuYW5ub3RhdGlvbnN9XFxuVGFnczogJHtlbnRyeS5tZXRhZGF0YS50YWdzfWBcbiAgICApLmpvaW4oJ1xcblxcbicpOyBcbiAgICByZXR1cm4gZm9ybWF0dGVkUmVzdWx0cztcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBxdWVyeWluZyBQaW5lY29uZTpcIiwgZXJyb3IpO1xuICAgIHJldHVybiAnICc7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBmdW5jdGlvbiBmb3IgZXh0ZXJuYWwgdXNhZ2UuXG5leHBvcnQgeyBxdWVyeVBpbmVjb25lIH07XG5cbi8vIFRlc3QgZnVuY3Rpb24gdG8gdmVyaWZ5IFBpbmVjb25lIHF1ZXJ5IGZ1bmN0aW9uYWxpdHlcbi8vIERFTEVURSBMQVRFUi5cbi8qYXN5bmMgZnVuY3Rpb24gdGVzdFBpbmVjb25lUmV0cmlldmUoKSB7XG4gIGNvbnN0IHVzZXJfaWQgPSAndGVzdF91c2VyJztcbiAgY29uc3Qgd29ya3NwYWNlX2lkID0gJ3Rlc3Rfd29ya3NwYWNlJztcbiAgY29uc3QgcXVlcnkgPSAnSnVsaXVzIENlc2Vhcic7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwaW5lY29uZVJlc3BvbnNlID0gYXdhaXQgcXVlcnlQaW5lY29uZShxdWVyeSwgdXNlcl9pZCwgd29ya3NwYWNlX2lkKTtcbiAgICBjb25zb2xlLmxvZygnUmF3IFBpbmVjb25lIFJlc3BvbnNlOicsIHBpbmVjb25lUmVzcG9uc2UpO1xuXG4gICAgcGluZWNvbmVSZXNwb25zZS5mb3JFYWNoKChlbnRyeSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBSZXN1bHQgJHtpbmRleCArIDF9OmApO1xuICAgICAgY29uc29sZS5sb2coJ1RleHQ6JywgZW50cnkubWV0YWRhdGEudGV4dCk7XG4gICAgICBjb25zb2xlLmxvZygnU291cmNlIEluZm86JywgZW50cnkubWV0YWRhdGEuc291cmNlX2luZm8pO1xuICAgICAgY29uc29sZS5sb2coJ0Fubm90YXRpb25zOicsIGVudHJ5Lm1ldGFkYXRhLmFubm90YXRpb25zKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUYWdzOicsIGVudHJ5Lm1ldGFkYXRhLnRhZ3MpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY29tYmluZWRTdHJpbmcgPSBwaW5lY29uZVJlc3BvbnNlLm1hcChlbnRyeSA9PlxuICAgICAgYCR7ZW50cnkubWV0YWRhdGEudGV4dH1cXG5Tb3VyY2UgSW5mbzogJHtlbnRyeS5tZXRhZGF0YS5zb3VyY2VfaW5mb31cXG5Bbm5vdGF0aW9uczogJHtlbnRyeS5tZXRhZGF0YS5hbm5vdGF0aW9uc31cXG5UYWdzOiAke2VudHJ5Lm1ldGFkYXRhLnRhZ3N9YFxuICAgICkuam9pbignXFxuXFxuJyk7XG5cbiAgICBjb25zb2xlLmxvZygnQ29tYmluZWQgU3RyaW5nOicsIGNvbWJpbmVkU3RyaW5nKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXRyaWV2aW5nIGRhdGEgZnJvbSBQaW5lY29uZTonLCBlcnJvcik7XG4gIH1cbn1cblxuLy8gUnVuIHRoZSB0ZXN0XG50ZXN0UGluZWNvbmVSZXRyaWV2ZSgpO1xuKi9cblxuLypcbiAgQ29kZSB3b3Jrc1xuICBGdXR1cmUgcGxhbnM6XG4gIEJldHRlciBlcnJvciBoYW5kbGluZyBhbmQgbG9nZ2luZy5cbiAgTGV0IHVzZXJzIHVzZSB0aGVpciBvd24ga2V5cy5cbiAgUmVmcmFjdG9yIGNvZGUgZm9yIG1vZGFsaXR5LiBcbiAgICBFbWJlZGRpbmcgc2hvdWxkIGJlIGRvbmUgaW4gc2VwcmF0ZSBwcm9ncmFtIGFuZCBzaGFyZWQgd2l0aCB1cGxvYWQuXG4gICAgUGluZWNvbmUgaW5pdGlsaXphdGlvbiBzaG91bGQgYmUgZG9uZSBpbiBzZXBlcmF0ZSBwcm9ncmFtIGFuZCBzaGFyZWQgd2l0aCB1cGxvYWQuXG4gICAgSW5pdGlsaXplIHBpbmVjb25lIG9uY2UgYXQgc3RhcnQgb2YgYXBwIGFuZCByZXVzZSBzYW1lIGNvbm5lY3Rpb24gdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgS2VlcCBhIGNhY2hlIG9mIGVtYmVkZGluZ3MgaW4gbWVtb3J5IGZvciBzaW1pbGFyIHF1ZXJpZXMgLT4gXG4gICAgY2FuIG1hdGNoIHF1ZXJ5IHN0cmluZyBpbiBtZW1vcnkgdG8gZm9yZ28gZW1iZWRkaW5nIGFuZCBxdWVyeVxuICAgIGNhbiBtYXRjaCBlbWJlZGRpbmdzIGluIG1lbW9yeSB0byBmb3JnbyBwaW5lY29uZSBxdWVyeVxuICBIYW5kbGUgcXVlcmllcyBpbiBiYXRjaGVzIGZvciB3aGVuIG11bHRpcGxlIHVzZXJzIGFyZSB1c2luZyBzYW1lIHBpbmVjb25lIGNvbm5lY3Rpb24uXG4gIEhhbmRsZSBjYXNlcyB3aGVuIHBpbmVjb25lIHJldHVybnMgbm8gcmVzdWx0IG9yIHJlc3VsdHMgdGhhdCBhcmUgdG9vIGRpZmZlcmVudCBmcm9tIHF1ZXJ5LlxuKi8iXSwibmFtZXMiOlsiZG90ZW52IiwiT3BlbkFJIiwiUGluZWNvbmUiLCJjb25maWciLCJvcGVuYWlDbGllbnQiLCJhcGlLZXkiLCJwaW5lY29uZSIsInByb2Nlc3MiLCJlbnYiLCJQSU5FQ09ORV9BUElfS0VZIiwiaW5kZXhOYW1lIiwiZ2VuZXJhdGVFbWJlZGRpbmciLCJxdWVyeSIsInJlc3BvbnNlIiwiZW1iZWRkaW5ncyIsImNyZWF0ZSIsIm1vZGVsIiwiaW5wdXQiLCJkYXRhIiwiZW1iZWRkaW5nIiwiZXJyb3IiLCJjb25zb2xlIiwicXVlcnlQaW5lY29uZSIsInVzZXJJZCIsIndvcmtzcGFjZUlkIiwidG9wSyIsInF1ZXJ5RW1iZWRkaW5nIiwiaW5kZXgiLCJJbmRleCIsInZlY3RvciIsImluY2x1ZGVNZXRhZGF0YSIsImZpbHRlciIsInVzZXJfaWQiLCJ3b3Jrc3BhY2VfaWQiLCJmb3JtYXR0ZWRSZXN1bHRzIiwibWF0Y2hlcyIsIm1hcCIsImVudHJ5IiwibWV0YWRhdGEiLCJ0ZXh0Iiwic291cmNlX2luZm8iLCJhbm5vdGF0aW9ucyIsInRhZ3MiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/pinecone_operations/pinecone_retrieve.js\n"));

/***/ })

});